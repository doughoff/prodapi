// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package postgres

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type MovementType string

const (
	MovementTypePURCHASE      MovementType = "PURCHASE"
	MovementTypeADJUST        MovementType = "ADJUST"
	MovementTypeSALE          MovementType = "SALE"
	MovementTypePRODUCTIONOUT MovementType = "PRODUCTION_OUT"
	MovementTypePRODUCTIONIN  MovementType = "PRODUCTION_IN"
)

func (e *MovementType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MovementType(s)
	case string:
		*e = MovementType(s)
	default:
		return fmt.Errorf("unsupported scan type for MovementType: %T", src)
	}
	return nil
}

type NullMovementType struct {
	MovementType MovementType
	Valid        bool // Valid is true if MovementType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMovementType) Scan(value interface{}) error {
	if value == nil {
		ns.MovementType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MovementType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMovementType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MovementType), nil
}

func (e MovementType) Valid() bool {
	switch e {
	case MovementTypePURCHASE,
		MovementTypeADJUST,
		MovementTypeSALE,
		MovementTypePRODUCTIONOUT,
		MovementTypePRODUCTIONIN:
		return true
	}
	return false
}

type Status string

const (
	StatusACTIVE   Status = "ACTIVE"
	StatusINACTIVE Status = "INACTIVE"
)

func (e *Status) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Status(s)
	case string:
		*e = Status(s)
	default:
		return fmt.Errorf("unsupported scan type for Status: %T", src)
	}
	return nil
}

type NullStatus struct {
	Status Status
	Valid  bool // Valid is true if Status is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullStatus) Scan(value interface{}) error {
	if value == nil {
		ns.Status, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Status.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Status), nil
}

func (e Status) Valid() bool {
	switch e {
	case StatusACTIVE,
		StatusINACTIVE:
		return true
	}
	return false
}

type Unit string

const (
	UnitKG    Unit = "KG"
	UnitL     Unit = "L"
	UnitUNITS Unit = "UNITS"
	UnitOTHER Unit = "OTHER"
)

func (e *Unit) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Unit(s)
	case string:
		*e = Unit(s)
	default:
		return fmt.Errorf("unsupported scan type for Unit: %T", src)
	}
	return nil
}

type NullUnit struct {
	Unit  Unit
	Valid bool // Valid is true if Unit is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUnit) Scan(value interface{}) error {
	if value == nil {
		ns.Unit, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Unit.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUnit) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Unit), nil
}

func (e Unit) Valid() bool {
	switch e {
	case UnitKG,
		UnitL,
		UnitUNITS,
		UnitOTHER:
		return true
	}
	return false
}

type Entity struct {
	ID        pgtype.UUID
	Status    Status
	Name      string
	Ci        pgtype.Text
	Ruc       pgtype.Text
	CreatedAt pgtype.Timestamp
	UpdatedAt pgtype.Timestamp
}

type Product struct {
	ID               pgtype.UUID
	Status           Status
	Name             string
	Barcode          string
	Unit             Unit
	BatchControl     bool
	ConversionFactor pgtype.Numeric
	CreatedAt        pgtype.Timestamp
	UpdatedAt        pgtype.Timestamp
}

type Recipe struct {
	RecipeID        pgtype.UUID
	RecipeGroupID   pgtype.UUID
	Name            string
	Status          Status
	Revision        int32
	IsCurrent       bool
	CreatedByUserID pgtype.UUID
	CreatedAt       pgtype.Timestamp
}

type RecipeIngredient struct {
	ID        pgtype.UUID
	RecipeID  pgtype.UUID
	ProductID pgtype.UUID
	Quantity  int32
}

type StockMovement struct {
	ID                pgtype.UUID
	Status            Status
	Type              MovementType
	Date              pgtype.Date
	EntityID          pgtype.UUID
	CreatedByUserID   pgtype.UUID
	CancelledByUserID pgtype.UUID
	CreatedAt         pgtype.Timestamp
	UpdatedAt         pgtype.Timestamp
}

type StockMovementItem struct {
	ID              pgtype.UUID
	StockMovementID pgtype.UUID
	ProductID       pgtype.UUID
	Quantity        int32
	Price           int32
	Batch           pgtype.Text
	CreatedAt       pgtype.Timestamp
	UpdatedAt       pgtype.Timestamp
}

type User struct {
	ID        pgtype.UUID
	Status    Status
	Email     string
	Name      string
	Password  string
	Roles     []string
	CreatedAt pgtype.Timestamp
	UpdatedAt pgtype.Timestamp
}
