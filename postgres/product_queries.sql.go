// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: product_queries.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProduct = `-- name: CreateProduct :one
insert into products (name, barcode, unit, batch_control, conversion_factor)
values ($1, $2, $3, $4, $5)
returning id, status, name, barcode, unit, batch_control, conversion_factor, created_at, updated_at
`

type CreateProductParams struct {
	Name             string
	Barcode          string
	Unit             Unit
	BatchControl     bool
	ConversionFactor int64
}

func (q *Queries) CreateProduct(ctx context.Context, db DBTX, arg *CreateProductParams) (*Product, error) {
	row := db.QueryRow(ctx, createProduct,
		arg.Name,
		arg.Barcode,
		arg.Unit,
		arg.BatchControl,
		arg.ConversionFactor,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Name,
		&i.Barcode,
		&i.Unit,
		&i.BatchControl,
		&i.ConversionFactor,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getProductByBarcode = `-- name: GetProductByBarcode :one
select id, status, name, barcode, unit, batch_control, conversion_factor, created_at, updated_at
from products
where barcode = $1
limit 1
`

func (q *Queries) GetProductByBarcode(ctx context.Context, db DBTX, barcode string) (*Product, error) {
	row := db.QueryRow(ctx, getProductByBarcode, barcode)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Name,
		&i.Barcode,
		&i.Unit,
		&i.BatchControl,
		&i.ConversionFactor,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getProductByID = `-- name: GetProductByID :one
select id, status, name, barcode, unit, batch_control, conversion_factor, created_at, updated_at
from products
where id = $1
limit 1
`

func (q *Queries) GetProductByID(ctx context.Context, db DBTX, id pgtype.UUID) (*Product, error) {
	row := db.QueryRow(ctx, getProductByID, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Name,
		&i.Barcode,
		&i.Unit,
		&i.BatchControl,
		&i.ConversionFactor,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getProducts = `-- name: GetProducts :many
select count(*) over () as full_count,
       p.id, p.status, p.name, p.barcode, p.unit, p.batch_control, p.conversion_factor, p.created_at, p.updated_at
from products p
where p.status = ANY ($1::status[])
  and (
            p.name ilike '%' || $2 || '%'
        or p.barcode ilike '%' || $2 || '%'
    )
order by created_at desc
limit $4 offset $3
`

type GetProductsParams struct {
	StatusOptions []Status
	Search        pgtype.Text
	PageOffset    int32
	PageLimit     int32
}

type GetProductsRow struct {
	FullCount        int64
	ID               pgtype.UUID
	Status           Status
	Name             string
	Barcode          string
	Unit             Unit
	BatchControl     bool
	ConversionFactor int64
	CreatedAt        pgtype.Timestamp
	UpdatedAt        pgtype.Timestamp
}

func (q *Queries) GetProducts(ctx context.Context, db DBTX, arg *GetProductsParams) ([]*GetProductsRow, error) {
	rows, err := db.Query(ctx, getProducts,
		arg.StatusOptions,
		arg.Search,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetProductsRow{}
	for rows.Next() {
		var i GetProductsRow
		if err := rows.Scan(
			&i.FullCount,
			&i.ID,
			&i.Status,
			&i.Name,
			&i.Barcode,
			&i.Unit,
			&i.BatchControl,
			&i.ConversionFactor,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProductByID = `-- name: UpdateProductByID :one
update products
set status            = $1,
    name              = $2,
    barcode           = $3,
    unit              = $4,
    batch_control     = $5,
    conversion_factor = $6
where id = $7
returning id, status, name, barcode, unit, batch_control, conversion_factor, created_at, updated_at
`

type UpdateProductByIDParams struct {
	Status           Status
	Name             string
	Barcode          string
	Unit             Unit
	BatchControl     bool
	ConversionFactor int64
	ID               pgtype.UUID
}

func (q *Queries) UpdateProductByID(ctx context.Context, db DBTX, arg *UpdateProductByIDParams) (*Product, error) {
	row := db.QueryRow(ctx, updateProductByID,
		arg.Status,
		arg.Name,
		arg.Barcode,
		arg.Unit,
		arg.BatchControl,
		arg.ConversionFactor,
		arg.ID,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Name,
		&i.Barcode,
		&i.Unit,
		&i.BatchControl,
		&i.ConversionFactor,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
