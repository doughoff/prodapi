// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: production_order_queries.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getOrderCyclesMovements = `-- name: GetOrderCyclesMovements :many
select ocm.id,
       ocm.cycle_id,
       ocm.movement_id,
       coalesce(ri.recipe_id, smi.product_id) as product_id,
       coalesce(smi.quantity, 0) as cantidad,
       coalesce(smi.price, 0) as price
from order_cycles_movements ocm
         join production_order_cycles poc on ocm.cycle_id = poc.id
         left join production_orders po on poc.production_order_id = po.id
         left join recipe_ingredients ri on po.recipe_id = ri.recipe_id
         left join stock_movement_items smi on ocm.movement_id = smi.stock_movement_id
where ocm.cycle_id = any ($1::uuid[])
`

type GetOrderCyclesMovementsRow struct {
	ID         pgtype.UUID
	CycleID    pgtype.UUID
	MovementID pgtype.UUID
	ProductID  pgtype.UUID
	Cantidad   int64
	Price      int64
}

func (q *Queries) GetOrderCyclesMovements(ctx context.Context, db DBTX, cycleIds []pgtype.UUID) ([]*GetOrderCyclesMovementsRow, error) {
	rows, err := db.Query(ctx, getOrderCyclesMovements, cycleIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetOrderCyclesMovementsRow{}
	for rows.Next() {
		var i GetOrderCyclesMovementsRow
		if err := rows.Scan(
			&i.ID,
			&i.CycleID,
			&i.MovementID,
			&i.ProductID,
			&i.Cantidad,
			&i.Price,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductionOrderByID = `-- name: GetProductionOrderByID :one
SELECT po.id,
       po.status,
       po.production_step,
       po.code,
       po.cycles,
       po.recipe_id,
       r.name,
       r.produced_quantity,
       p.name,
       p.unit,
       po.created_by_user_id,
       u.name  as create_by_user_name,
       po.cancelled_by_user_id,
       ud.name as cancelled_by_user_name,
       po.created_at
from production_orders po
         left join recipes r on po.recipe_id = r.recipe_id
         left join products p on r.product_id = p.id
         left join users u on po.created_by_user_id = u.id
         left join users ud on po.cancelled_by_user_id = ud.id
where po.id = $1
`

type GetProductionOrderByIDRow struct {
	ID                  pgtype.UUID
	Status              Status
	ProductionStep      ProductionStep
	Code                string
	Cycles              int64
	RecipeID            pgtype.UUID
	Name                pgtype.Text
	ProducedQuantity    pgtype.Int8
	Name_2              pgtype.Text
	Unit                NullUnit
	CreatedByUserID     pgtype.UUID
	CreateByUserName    pgtype.Text
	CancelledByUserID   pgtype.UUID
	CancelledByUserName pgtype.Text
	CreatedAt           pgtype.Timestamp
}

func (q *Queries) GetProductionOrderByID(ctx context.Context, db DBTX, productionOrderID pgtype.UUID) (*GetProductionOrderByIDRow, error) {
	row := db.QueryRow(ctx, getProductionOrderByID, productionOrderID)
	var i GetProductionOrderByIDRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.ProductionStep,
		&i.Code,
		&i.Cycles,
		&i.RecipeID,
		&i.Name,
		&i.ProducedQuantity,
		&i.Name_2,
		&i.Unit,
		&i.CreatedByUserID,
		&i.CreateByUserName,
		&i.CancelledByUserID,
		&i.CancelledByUserName,
		&i.CreatedAt,
	)
	return &i, err
}

const getProductionOrderCycles = `-- name: GetProductionOrderCycles :many
select poc.id,
       factor,
       production_order_id,
       production_step,
       cycle_order,
       completed_at
from production_order_cycles poc
where poc.production_order_id = any ($1::uuid[])
`

func (q *Queries) GetProductionOrderCycles(ctx context.Context, db DBTX, productionOrderIds []pgtype.UUID) ([]*ProductionOrderCycle, error) {
	rows, err := db.Query(ctx, getProductionOrderCycles, productionOrderIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ProductionOrderCycle{}
	for rows.Next() {
		var i ProductionOrderCycle
		if err := rows.Scan(
			&i.ID,
			&i.Factor,
			&i.ProductionOrderID,
			&i.ProductionStep,
			&i.CycleOrder,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductionOrderMovements = `-- name: GetProductionOrderMovements :many
select poc.id, factor, production_order_id, production_step, cycle_order, completed_at, ocm.id, cycle_id, movement_id, sm.id, status, type, date, entity_id, created_by_user_id, cancelled_by_user_id, created_at, updated_at, document_number
from production_order_cycles poc
    join order_cycles_movements ocm on poc.id = ocm.cycle_id
    join stock_movements sm on ocm.movement_id = sm.id
where poc.production_order_id = $1
`

type GetProductionOrderMovementsRow struct {
	ID                pgtype.UUID
	Factor            int64
	ProductionOrderID pgtype.UUID
	ProductionStep    ProductionStep
	CycleOrder        int64
	CompletedAt       pgtype.Timestamp
	ID_2              pgtype.UUID
	CycleID           pgtype.UUID
	MovementID        pgtype.UUID
	ID_3              pgtype.UUID
	Status            Status
	Type              MovementType
	Date              pgtype.Date
	EntityID          pgtype.UUID
	CreatedByUserID   pgtype.UUID
	CancelledByUserID pgtype.UUID
	CreatedAt         pgtype.Timestamp
	UpdatedAt         pgtype.Timestamp
	DocumentNumber    pgtype.Text
}

func (q *Queries) GetProductionOrderMovements(ctx context.Context, db DBTX, productionOrderID pgtype.UUID) ([]*GetProductionOrderMovementsRow, error) {
	rows, err := db.Query(ctx, getProductionOrderMovements, productionOrderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetProductionOrderMovementsRow{}
	for rows.Next() {
		var i GetProductionOrderMovementsRow
		if err := rows.Scan(
			&i.ID,
			&i.Factor,
			&i.ProductionOrderID,
			&i.ProductionStep,
			&i.CycleOrder,
			&i.CompletedAt,
			&i.ID_2,
			&i.CycleID,
			&i.MovementID,
			&i.ID_3,
			&i.Status,
			&i.Type,
			&i.Date,
			&i.EntityID,
			&i.CreatedByUserID,
			&i.CancelledByUserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DocumentNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductionOrders = `-- name: GetProductionOrders :many
SELECT count(*) over () as full_count,
       po.id,
       po.status,
       po.production_step,
       po.code,
       po.cycles,
       po.recipe_id,
       r.name,
       r.produced_quantity,
       p.name,
       p.unit,
       po.created_by_user_id,
       u.name           as create_by_user_name,
       po.cancelled_by_user_id,
       ud.name          as cancelled_by_user_name,
       po.created_at
from production_orders po
         left join recipes r on po.recipe_id = r.recipe_id
         left join products p on r.product_id = p.id
         left join users u on po.created_by_user_id = u.id
         left join users ud on po.cancelled_by_user_id = ud.id
where po.status = any ($1::status[])
  and (
            r.name ilike '%' || $2 || '%'
        or p.name ilike '%' || $2 || '%'
    )
  and po.created_at >= $3
order by po.created_at desc
limit $5 offset $4
`

type GetProductionOrdersParams struct {
	StatusOptiuons []Status
	Search         pgtype.Text
	StartDate      pgtype.Timestamp
	PageOffset     int32
	PageLimit      int32
}

type GetProductionOrdersRow struct {
	FullCount           int64
	ID                  pgtype.UUID
	Status              Status
	ProductionStep      ProductionStep
	Code                string
	Cycles              int64
	RecipeID            pgtype.UUID
	Name                pgtype.Text
	ProducedQuantity    pgtype.Int8
	Name_2              pgtype.Text
	Unit                NullUnit
	CreatedByUserID     pgtype.UUID
	CreateByUserName    pgtype.Text
	CancelledByUserID   pgtype.UUID
	CancelledByUserName pgtype.Text
	CreatedAt           pgtype.Timestamp
}

func (q *Queries) GetProductionOrders(ctx context.Context, db DBTX, arg *GetProductionOrdersParams) ([]*GetProductionOrdersRow, error) {
	rows, err := db.Query(ctx, getProductionOrders,
		arg.StatusOptiuons,
		arg.Search,
		arg.StartDate,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetProductionOrdersRow{}
	for rows.Next() {
		var i GetProductionOrdersRow
		if err := rows.Scan(
			&i.FullCount,
			&i.ID,
			&i.Status,
			&i.ProductionStep,
			&i.Code,
			&i.Cycles,
			&i.RecipeID,
			&i.Name,
			&i.ProducedQuantity,
			&i.Name_2,
			&i.Unit,
			&i.CreatedByUserID,
			&i.CreateByUserName,
			&i.CancelledByUserID,
			&i.CancelledByUserName,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
