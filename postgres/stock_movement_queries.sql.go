// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: stock_movement_queries.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createStockMovement = `-- name: CreateStockMovement :one
insert into stock_movements(
                            type,
                            date,
                            entity_id,
                            created_by_user_id,
                            document_number
                            )
values ($1, $2, $3, $4, $5)
returning id
`

type CreateStockMovementParams struct {
	Type            MovementType
	Date            pgtype.Date
	EntityID        pgtype.UUID
	CreatedByUserID pgtype.UUID
	DocumentNumber  pgtype.Text
}

func (q *Queries) CreateStockMovement(ctx context.Context, db DBTX, arg *CreateStockMovementParams) (pgtype.UUID, error) {
	row := db.QueryRow(ctx, createStockMovement,
		arg.Type,
		arg.Date,
		arg.EntityID,
		arg.CreatedByUserID,
		arg.DocumentNumber,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

type CreateStockMovementItemsParams struct {
	StockMovementID pgtype.UUID
	ProductID       pgtype.UUID
	Quantity        int64
	Price           int64
	Batch           pgtype.Text
}

const getStockMovementByID = `-- name: GetStockMovementByID :one
SELECT si.id,
       si.status,
       si.type,
       si.date,
       si.entity_id,
       si.document_number,
       e.name  as entity_name,
       si.created_by_user_id,
       u.name  as create_by_user_name,
       si.cancelled_by_user_id,
       uc.name as cancelled_by_user_name
from stock_movements si
         left join entities e on si.entity_id = e.id
         left join users uc on si.cancelled_by_user_id = uc.id
         left join users u on si.created_by_user_id = u.id
where si.id = $1
`

type GetStockMovementByIDRow struct {
	ID                  pgtype.UUID
	Status              Status
	Type                MovementType
	Date                pgtype.Date
	EntityID            pgtype.UUID
	DocumentNumber      pgtype.Text
	EntityName          pgtype.Text
	CreatedByUserID     pgtype.UUID
	CreateByUserName    pgtype.Text
	CancelledByUserID   pgtype.UUID
	CancelledByUserName pgtype.Text
}

func (q *Queries) GetStockMovementByID(ctx context.Context, db DBTX, stockMovementID pgtype.UUID) (*GetStockMovementByIDRow, error) {
	row := db.QueryRow(ctx, getStockMovementByID, stockMovementID)
	var i GetStockMovementByIDRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Type,
		&i.Date,
		&i.EntityID,
		&i.DocumentNumber,
		&i.EntityName,
		&i.CreatedByUserID,
		&i.CreateByUserName,
		&i.CancelledByUserID,
		&i.CancelledByUserName,
	)
	return &i, err
}

const getStockMovementItems = `-- name: GetStockMovementItems :many
select smi.id,
       smi.stock_movement_id,
       smi.product_id,
       p.name as product_name,
       smi.quantity,
       smi.price,
       smi.batch,
       smi.created_at,
       smi.updated_at
from stock_movement_items smi
         left join products p on smi.product_id = p.id
where smi.stock_movement_id = any ($1::uuid[])
`

type GetStockMovementItemsRow struct {
	ID              pgtype.UUID
	StockMovementID pgtype.UUID
	ProductID       pgtype.UUID
	ProductName     pgtype.Text
	Quantity        int64
	Price           int64
	Batch           pgtype.Text
	CreatedAt       pgtype.Timestamp
	UpdatedAt       pgtype.Timestamp
}

func (q *Queries) GetStockMovementItems(ctx context.Context, db DBTX, stockMovementIds []pgtype.UUID) ([]*GetStockMovementItemsRow, error) {
	rows, err := db.Query(ctx, getStockMovementItems, stockMovementIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetStockMovementItemsRow{}
	for rows.Next() {
		var i GetStockMovementItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.StockMovementID,
			&i.ProductID,
			&i.ProductName,
			&i.Quantity,
			&i.Price,
			&i.Batch,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStockMovements = `-- name: GetStockMovements :many
SELECT count(*) over () as full_count,
       si.id,
       si.status,
       si.type,
       si.date,
       si.entity_id,
       si.document_number,
       e.name           as entity_name,
       si.created_by_user_id,
       u.name           as create_by_user_name,
       si.cancelled_by_user_id,
       uc.name          as cancelled_by_user_name
from stock_movements si
         left join entities e on si.entity_id = e.id
         left join users uc on si.cancelled_by_user_id = uc.id
         left join users u on si.created_by_user_id = u.id
where si.status = any ($1::status[])
  and (
        e.name ilike '%' || $2 || '%'
      or si.document_number ilike '%' || $2 || '%'
    )
  and si.date >= $3
order by si.date desc
limit $5 offset $4
`

type GetStockMovementsParams struct {
	StatusOptions []Status
	Search        pgtype.Text
	StartDate     pgtype.Date
	PageOffset    int32
	PageLimit     int32
}

type GetStockMovementsRow struct {
	FullCount           int64
	ID                  pgtype.UUID
	Status              Status
	Type                MovementType
	Date                pgtype.Date
	EntityID            pgtype.UUID
	DocumentNumber      pgtype.Text
	EntityName          pgtype.Text
	CreatedByUserID     pgtype.UUID
	CreateByUserName    pgtype.Text
	CancelledByUserID   pgtype.UUID
	CancelledByUserName pgtype.Text
}

func (q *Queries) GetStockMovements(ctx context.Context, db DBTX, arg *GetStockMovementsParams) ([]*GetStockMovementsRow, error) {
	rows, err := db.Query(ctx, getStockMovements,
		arg.StatusOptions,
		arg.Search,
		arg.StartDate,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetStockMovementsRow{}
	for rows.Next() {
		var i GetStockMovementsRow
		if err := rows.Scan(
			&i.FullCount,
			&i.ID,
			&i.Status,
			&i.Type,
			&i.Date,
			&i.EntityID,
			&i.DocumentNumber,
			&i.EntityName,
			&i.CreatedByUserID,
			&i.CreateByUserName,
			&i.CancelledByUserID,
			&i.CancelledByUserName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStockMovement = `-- name: UpdateStockMovement :exec
update stock_movements
 set status = $1,
     entity_id = $2,
     date = $3,
     document_number = $4
where id = $5
`

type UpdateStockMovementParams struct {
	Status         Status
	EntityID       pgtype.UUID
	Date           pgtype.Date
	DocumentNumber pgtype.Text
	ID             pgtype.UUID
}

func (q *Queries) UpdateStockMovement(ctx context.Context, db DBTX, arg *UpdateStockMovementParams) error {
	_, err := db.Exec(ctx, updateStockMovement,
		arg.Status,
		arg.EntityID,
		arg.Date,
		arg.DocumentNumber,
		arg.ID,
	)
	return err
}
